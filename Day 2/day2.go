package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

/** This program will determine the position of our submarine based on the commands
/** found in instructions.txt
**/

type Position struct {
	Horizontal int
	Depth      int
	Aim        int
	Command    string
	Commands   []string
	Movement   int
	Movements  []int
}

func main() {
	p := Position{}
	p.open()
	p.calculateAnswer2()

}

// Open() will read in the commands line by line from instructions.txt
func (p *Position) open() {

	// Opens the instructions.txt file and stores it in f
	f, err := os.Open("instructions.txt")
	if err != nil {
		log.Println(err)
	}

	// Splits on newlines
	scanner := bufio.NewScanner(f)

	// Iterate through each line of f based on newline
	for scanner.Scan() {
		// Further iterate through each line based on the separating space
		_, err := fmt.Sscan(scanner.Text(), &p.Command, &p.Movement)
		if err != nil {
			log.Println(err)
		}

		// Add the command string and movement integer to their respective slices
		p.Movements = append(p.Movements, p.Movement)
		p.Commands = append(p.Commands, p.Command)
	}

	// Handle any errors generated by scanner.Scan()
	if err := scanner.Err(); err != nil {
		log.Println(err)
	}

}

// calculate() will calculate the submarine's position by iterating through
// both slices in the Position struct
func (p *Position) calculateAnswer1() {
	for i, command := range p.Commands {
		if command == "forward" {
			p.Horizontal += p.Movements[i]
		} else if command == "down" {
			p.Depth += p.Movements[i]
		} else {
			p.Depth -= p.Movements[i]
		}
	}

	// Answer is the product of p.Horizontal and p.Depth values
	fmt.Println(p.Horizontal * p.Depth)
}

func (p *Position) calculateAnswer2() {
	for i, command := range p.Commands {
		if command == "forward" {
			p.Horizontal += p.Movements[i]
			p.Depth += (p.Aim * p.Movements[i])
		} else if command == "down" {
			p.Aim += p.Movements[i]
		} else {
			p.Aim -= p.Movements[i]
		}
	}

	// Answer is the product of p.Horizontal and p.Depth values
	fmt.Println(p.Horizontal * p.Depth)
}
